---
title: "Predicting Future Scooter Movement - Poisson Regression"
output: html_document
editor_options: 
  chunk_output_type: console
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Introdcution 
We want to predict and model the position of the scooters position in the future. 

We estimate that the scooter rides starting in a given cell of the grid follows a poission distribution. That is linearly dependent on the cells poistion, the hour of the day and the day of the week. (Later one can add other covariates such as weather, and month)

We start by fitting a generelized linear model based on the possion family.

```{r}
library(dplyr)
library("rgdal")
library("sf")
library(ggmap)
# Reading data
df <- read.csv("processed-data/output10min.csv", nrows = 100000)

# Removing index columns
df <- df[,-c(1,2)]
# Add columns about time stamps
df$time <- as.POSIXct(df$time, "%Y-%m-%d %H:%M:%S", tz="Europe/Paris")
df.trips <- df[df$distanceTravelled > 50 & df$distanceTravelled < 15000,]
# Finding start and end of trips
df.trip <- df %>% group_by(operator, id) %>% mutate(isEnd = ifelse((lead(distanceTravelled)<50 | lead(distanceTravelled)>3000) & (distanceTravelled > 50 | distanceTravelled > 3000),1,0),
                                               isStart = ifelse((distanceTravelled < 50 | distanceTravelled > 3000) & (lead(distanceTravelled) > 50 & lead(distanceTravelled) < 3000),1,0)) %>% ungroup()

# Finding intervals part of a trip inbetween strat and end. 
df.trip <- df.trip %>% group_by(operator, id) %>% mutate(isMid = ifelse((lead(isStart) == 1 | (lead(distanceTravelled)> 50 & lead(distanceTravelled) < 3000)) & (lag(distanceTravelled)> 50 & lag(distanceTravelled) < 3000),1,0)) %>% ungroup()

df.trip$monthDay <- strftime(df$time, format = "%m/%d")
df.trip$weekday <- strftime(df$time, format = "%a")

df.trip <- df.trip %>%
  st_as_sf(coords = c("lon", "lat"), crs = "+proj=longlat +zone=33") %>%
  st_transform(crs="+proj=utm +zone=33") %>%st_crop(xmin = 254328.471, xmax = 268685.126, ymin = 6646893.804, ymax = 6655335.032)

df.start <- df.trip[df.trip$isStart == 1,]
df.start <- df.start[!is.na(df.start$time),]
```


Make grid:
```{r}
coast <- st_read('gis/shapeFiles/land_polygons.shp')
coast.c <- st_crop(coast, xmin = 10.54433, xmax = 10.92609, ymin = 59.88134, ymax = 59.98148)
coast.c <- st_transform(coast.c, CRS("+proj=utm +zone=33 ellps=WGS84"))


grid <- st_make_grid(coast.c, cellsize = c(150, 150))
grid <- st_intersection(coast.c, grid)
grid$grid_id <- 1:nrow(grid)
grid <- grid[,c("grid_id","geometry")]
```

Start rate parameter:
```{r}
df.start <- df.start  %>% st_join(grid, join = st_intersects) %>% as.data.frame()
df.start$weekday <- strftime(df.start$time, format = "%a")

df.start_count <- df.start %>% group_by(grid_id, hour, weekday, year, month, day) %>% summarise(started_trips = n())
df.start_count <- na.omit(df.start_count)

```

Where does trips go? 
```{r}
df.trip <- df.trip %>% st_join(grid, join = st_intersects) %>% as.data.frame()


df.start_end <- df.trip[df.trip$isStart == 1 | df.trip$isEnd == 1,]
df.start_end <- df.start_end[!is.na(df.start_end$time),]

df.start_end <- df.start_end %>% group_by(operator, id) %>% mutate(start_grid = grid_id, end_grid = lead(grid_id))
df.start_end <- df.start_end[df.start_end$isStart == 1, ]
df.start_end <- df.start_end %>% group_by(start_grid, end_grid) %>% summarise(n=n()) # if more data can use hour and weekday here
df.start_end <- na.omit(df.start_end)
df.start_end <- df.start_end %>% group_by(start_grid) %>% mutate(p = n/n())


## How many scooter in area?
df.grid_count <- df.trip %>% group_by(grid_id, hour, weekday, day, month, year) %>% summarise(n = n_distinct(id))
df.grid_count <- na.omit(df.grid_count)

###
df.grid_movment <- left_join(df.start_count, df.grid_count, by=c("grid_id", "hour", "weekday", "day", "month", "year"))
```

Fit glm to estimate 
```{r}
model <- glm(started_trips ~ grid_id + hour + weekday + n, poisson, df.grid_movment)
summary(model)
```

Overdispersion:
```{r}
overdispersionparameter = model$deviance / model$df.residual
overdispersionparameter

p.overdisp <- pchisq(model$deviance, df=model$df.residual, lower.tail = F)
p.overdisp
```

```{r}
model <- glm(started_trips ~ grid_id + hour + weekday + n, quasipoisson(), df.grid_movment)
summary(model)

overdispersionparameter = model$deviance / model$df.residual
```
Simulating:
```{r}
df <- df.grid_movment
df$predicted_rate <- predict.glm(model, df, type="response")
df$started_rides <- rpois(nrow(df), df$predicted_rate)
df$scooters_left <- df$n - df$started_rides
df[df$scooters_left < 0,]$scooters_left = 0
df$started_rides <- df$n - df$scooters_left

i = 10
j = 1

count = 1
movement_probs <- runif(sum(df$started_rides), max = 1.2)
grids <- unique(df$grid_id)
for(i in 1:nrow(df)){
  if(df$started_rides > 0){
    for(j in 1:df[i,]$started_rides){
      from_grid = df[i,]$grid_id
      move_prob <- movement_probs[count]
      count = count + 1
      
      if(move_prob > 1){
        end_grid = sample(grids, 1)
      }
      to_grid =  
    }
  }
}


```
Predicting outcome:



